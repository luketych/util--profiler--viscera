{"{\"assumptions\":{},\"sourceRoot\":\"/Users/luketych/Dev/_util/profiler/viscera/codemods/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/luketych/Dev/_util/profiler/viscera\",\"filename\":\"/Users/luketych/Dev/_util/profiler/viscera/codemods/inject-profile-import.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/luketych/Dev/_util/profiler/viscera\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nconst {\n  dirname,\n  relative,\n  resolve\n} = require('path');\nconst {\n  fileURLToPath\n} = require('url');\n\n// Get the directory of the current module (the codemod file)\n// CommonJS doesn't have import.meta.url, use __filename instead\n// const __filename = fileURLToPath(import.meta.url);\nconst __dirname_codemod = __dirname; // Node provides __dirname in CJS\n\n/**\n * @param {import('jscodeshift').FileInfo} fileInfo\n * @param {import('jscodeshift').API} api\n */\nmodule.exports = function transformer(fileInfo, api) {\n  // Use module.exports\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n  const profileImportIdentifier = 'profileImport'; // Consistent identifier name\n  const markerString = '__AUTO_PROFILE__'; // Structural marker\n\n  // --- Calculate relative path dynamically ---\n  // Absolute path to profileImport.js source file\n  const profileImportAbsolutePath = resolve(__dirname_codemod, '../src/profileImport.js');\n  // Directory of the target file being transformed\n  const targetFileDir = dirname(fileInfo.path);\n  // Calculate the relative path FROM the target file's directory TO profileImport.js\n  let relativePathToProfileImport = relative(targetFileDir, profileImportAbsolutePath);\n  // Normalize path for import statements (e.g., ensure it starts with ./ or ../)\n  if (!relativePathToProfileImport.startsWith('.')) {\n    relativePathToProfileImport = './' + relativePathToProfileImport;\n  }\n  // console.log(`Calculated relative path to profileImport: ${relativePathToProfileImport}`);\n\n  // --- 1. Find or add the profileImport import declaration using calculated path ---\n  let importDeclaration = root.find(j.ImportDeclaration, {\n    source: {\n      type: 'Literal',\n      // Check if the existing import source resolves to the same absolute path\n      value: existingPath => resolve(targetFileDir, existingPath) === profileImportAbsolutePath\n    }\n  });\n  let isImportAdded = false;\n  if (importDeclaration.length === 0) {\n    // console.log(`Adding import for ${profileImportIdentifier} from ${relativePathToProfileImport}`);\n    importDeclaration = j.importDeclaration([j.importDefaultSpecifier(j.identifier(profileImportIdentifier))], j.literal(relativePathToProfileImport) // Use calculated relative path\n    );\n    // Insert the new import declaration at the beginning of the file body\n    const firstNodePath = root.find(j.Program).get('body', 0);\n    if (firstNodePath) {\n      firstNodePath.insertBefore(importDeclaration);\n    } else {\n      // Fallback if the body is empty (e.g., empty file)\n      root.get().node.body.push(importDeclaration);\n    }\n    isImportAdded = true;\n  } else {\n    // console.log(`Found existing import for ${profileImportIdentifier}`);\n  }\n\n  // --- 2. Find and transform dynamic imports, adding the marker argument ---\n  let changed = false;\n  root.find(j.ImportExpression).forEach(importPath => {\n    var _nodeToReplace$parent;\n    // console.log(`Found import: ${j(importPath).toSource()}`);\n\n    // Determine node to replace (the import or the await expression containing it)\n    let nodeToReplace = importPath;\n    if (importPath.parentPath.node.type === 'AwaitExpression') {\n      nodeToReplace = importPath.parentPath;\n    }\n\n    // Check for already wrapped import (basic check)\n    if (((_nodeToReplace$parent = nodeToReplace.parentPath) === null || _nodeToReplace$parent === void 0 || (_nodeToReplace$parent = _nodeToReplace$parent.value) === null || _nodeToReplace$parent === void 0 || (_nodeToReplace$parent = _nodeToReplace$parent.callee) === null || _nodeToReplace$parent === void 0 ? void 0 : _nodeToReplace$parent.name) === profileImportIdentifier) {\n      // console.log('     Skipping already wrapped import.');\n      return;\n    }\n\n    // Check if source is a Literal (dynamic imports require string literals)\n    if (importPath.value.source && importPath.value.source.type === 'Literal') {\n      const modulePathArg = importPath.value.source;\n\n      // Create 'import.meta.url'\n      const importMetaUrl = j.memberExpression(j.metaProperty(j.identifier('import'), j.identifier('meta')), j.identifier('url'));\n\n      // Create the marker argument\n      const markerArg = j.literal(markerString);\n\n      // Create profileImport(modulePath, import.meta.url, null, marker)\n      // Passing null for the _importer argument as it's for testing\n      const wrappedCall = j.callExpression(j.identifier(profileImportIdentifier), [modulePathArg, importMetaUrl, j.literal(null), markerArg]);\n\n      // Wrap in await if the original import was awaited\n      let replacementNode = nodeToReplace === importPath ? wrappedCall : j.awaitExpression(wrappedCall);\n      // console.log(`     Replacing with: ${j(replacementNode).toSource()}`);\n\n      j(nodeToReplace).replaceWith(replacementNode);\n      changed = true;\n    } else {\n      const sourceType = importPath.value.source ? importPath.value.source.type : 'undefined';\n      console.warn(`     Skipping dynamic import: Source is not a Literal (type: ${sourceType}). Source: ${j(importPath).toSource()}`);\n    }\n  });\n\n  // --- 3. Return modified source only if changes were made or import added ---\n  return changed || isImportAdded ? root.toSource({\n    quote: 'single'\n  }) : fileInfo.source; // Use single quotes for consistency\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkaXJuYW1lIiwicmVsYXRpdmUiLCJyZXNvbHZlIiwicmVxdWlyZSIsImZpbGVVUkxUb1BhdGgiLCJfX2Rpcm5hbWVfY29kZW1vZCIsIl9fZGlybmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0cmFuc2Zvcm1lciIsImZpbGVJbmZvIiwiYXBpIiwiaiIsImpzY29kZXNoaWZ0Iiwicm9vdCIsInNvdXJjZSIsInByb2ZpbGVJbXBvcnRJZGVudGlmaWVyIiwibWFya2VyU3RyaW5nIiwicHJvZmlsZUltcG9ydEFic29sdXRlUGF0aCIsInRhcmdldEZpbGVEaXIiLCJwYXRoIiwicmVsYXRpdmVQYXRoVG9Qcm9maWxlSW1wb3J0Iiwic3RhcnRzV2l0aCIsImltcG9ydERlY2xhcmF0aW9uIiwiZmluZCIsIkltcG9ydERlY2xhcmF0aW9uIiwidHlwZSIsInZhbHVlIiwiZXhpc3RpbmdQYXRoIiwiaXNJbXBvcnRBZGRlZCIsImxlbmd0aCIsImltcG9ydERlZmF1bHRTcGVjaWZpZXIiLCJpZGVudGlmaWVyIiwibGl0ZXJhbCIsImZpcnN0Tm9kZVBhdGgiLCJQcm9ncmFtIiwiZ2V0IiwiaW5zZXJ0QmVmb3JlIiwibm9kZSIsImJvZHkiLCJwdXNoIiwiY2hhbmdlZCIsIkltcG9ydEV4cHJlc3Npb24iLCJmb3JFYWNoIiwiaW1wb3J0UGF0aCIsIl9ub2RlVG9SZXBsYWNlJHBhcmVudCIsIm5vZGVUb1JlcGxhY2UiLCJwYXJlbnRQYXRoIiwiY2FsbGVlIiwibmFtZSIsIm1vZHVsZVBhdGhBcmciLCJpbXBvcnRNZXRhVXJsIiwibWVtYmVyRXhwcmVzc2lvbiIsIm1ldGFQcm9wZXJ0eSIsIm1hcmtlckFyZyIsIndyYXBwZWRDYWxsIiwiY2FsbEV4cHJlc3Npb24iLCJyZXBsYWNlbWVudE5vZGUiLCJhd2FpdEV4cHJlc3Npb24iLCJyZXBsYWNlV2l0aCIsInNvdXJjZVR5cGUiLCJjb25zb2xlIiwid2FybiIsInRvU291cmNlIiwicXVvdGUiXSwic291cmNlUm9vdCI6Ii9Vc2Vycy9sdWtldHljaC9EZXYvX3V0aWwvcHJvZmlsZXIvdmlzY2VyYS9jb2RlbW9kcy8iLCJzb3VyY2VzIjpbImluamVjdC1wcm9maWxlLWltcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGRpcm5hbWUsIHJlbGF0aXZlLCByZXNvbHZlIH0gPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7IGZpbGVVUkxUb1BhdGggfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG4vLyBHZXQgdGhlIGRpcmVjdG9yeSBvZiB0aGUgY3VycmVudCBtb2R1bGUgKHRoZSBjb2RlbW9kIGZpbGUpXG4vLyBDb21tb25KUyBkb2Vzbid0IGhhdmUgaW1wb3J0Lm1ldGEudXJsLCB1c2UgX19maWxlbmFtZSBpbnN0ZWFkXG4vLyBjb25zdCBfX2ZpbGVuYW1lID0gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpO1xuY29uc3QgX19kaXJuYW1lX2NvZGVtb2QgPSBfX2Rpcm5hbWU7IC8vIE5vZGUgcHJvdmlkZXMgX19kaXJuYW1lIGluIENKU1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdqc2NvZGVzaGlmdCcpLkZpbGVJbmZvfSBmaWxlSW5mb1xuICogQHBhcmFtIHtpbXBvcnQoJ2pzY29kZXNoaWZ0JykuQVBJfSBhcGlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1lcihmaWxlSW5mbywgYXBpKSB7IC8vIFVzZSBtb2R1bGUuZXhwb3J0c1xuXHRjb25zdCBqID0gYXBpLmpzY29kZXNoaWZ0O1xuXHRjb25zdCByb290ID0gaihmaWxlSW5mby5zb3VyY2UpO1xuXG5cdGNvbnN0IHByb2ZpbGVJbXBvcnRJZGVudGlmaWVyID0gJ3Byb2ZpbGVJbXBvcnQnOyAvLyBDb25zaXN0ZW50IGlkZW50aWZpZXIgbmFtZVxuXHRjb25zdCBtYXJrZXJTdHJpbmcgPSAnX19BVVRPX1BST0ZJTEVfXyc7IC8vIFN0cnVjdHVyYWwgbWFya2VyXG5cblx0Ly8gLS0tIENhbGN1bGF0ZSByZWxhdGl2ZSBwYXRoIGR5bmFtaWNhbGx5IC0tLVxuXHQvLyBBYnNvbHV0ZSBwYXRoIHRvIHByb2ZpbGVJbXBvcnQuanMgc291cmNlIGZpbGVcbiAgICBjb25zdCBwcm9maWxlSW1wb3J0QWJzb2x1dGVQYXRoID0gcmVzb2x2ZShfX2Rpcm5hbWVfY29kZW1vZCwgJy4uL3NyYy9wcm9maWxlSW1wb3J0LmpzJyk7XG4gICAgLy8gRGlyZWN0b3J5IG9mIHRoZSB0YXJnZXQgZmlsZSBiZWluZyB0cmFuc2Zvcm1lZFxuICAgIGNvbnN0IHRhcmdldEZpbGVEaXIgPSBkaXJuYW1lKGZpbGVJbmZvLnBhdGgpO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBGUk9NIHRoZSB0YXJnZXQgZmlsZSdzIGRpcmVjdG9yeSBUTyBwcm9maWxlSW1wb3J0LmpzXG4gICAgbGV0IHJlbGF0aXZlUGF0aFRvUHJvZmlsZUltcG9ydCA9IHJlbGF0aXZlKHRhcmdldEZpbGVEaXIsIHByb2ZpbGVJbXBvcnRBYnNvbHV0ZVBhdGgpO1xuICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGZvciBpbXBvcnQgc3RhdGVtZW50cyAoZS5nLiwgZW5zdXJlIGl0IHN0YXJ0cyB3aXRoIC4vIG9yIC4uLylcbiAgICBpZiAoIXJlbGF0aXZlUGF0aFRvUHJvZmlsZUltcG9ydC5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgIHJlbGF0aXZlUGF0aFRvUHJvZmlsZUltcG9ydCA9ICcuLycgKyByZWxhdGl2ZVBhdGhUb1Byb2ZpbGVJbXBvcnQ7XG4gICAgfVxuXHQvLyBjb25zb2xlLmxvZyhgQ2FsY3VsYXRlZCByZWxhdGl2ZSBwYXRoIHRvIHByb2ZpbGVJbXBvcnQ6ICR7cmVsYXRpdmVQYXRoVG9Qcm9maWxlSW1wb3J0fWApO1xuXG5cdC8vIC0tLSAxLiBGaW5kIG9yIGFkZCB0aGUgcHJvZmlsZUltcG9ydCBpbXBvcnQgZGVjbGFyYXRpb24gdXNpbmcgY2FsY3VsYXRlZCBwYXRoIC0tLVxuXHRsZXQgaW1wb3J0RGVjbGFyYXRpb24gPSByb290LmZpbmQoai5JbXBvcnREZWNsYXJhdGlvbiwge1xuXHRcdHNvdXJjZToge1xuXHRcdFx0dHlwZTogJ0xpdGVyYWwnLFxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIGV4aXN0aW5nIGltcG9ydCBzb3VyY2UgcmVzb2x2ZXMgdG8gdGhlIHNhbWUgYWJzb2x1dGUgcGF0aFxuXHRcdFx0dmFsdWU6IGV4aXN0aW5nUGF0aCA9PiByZXNvbHZlKHRhcmdldEZpbGVEaXIsIGV4aXN0aW5nUGF0aCkgPT09IHByb2ZpbGVJbXBvcnRBYnNvbHV0ZVBhdGhcblx0XHR9XG5cdH0pO1xuXG5cdGxldCBpc0ltcG9ydEFkZGVkID0gZmFsc2U7XG5cdGlmIChpbXBvcnREZWNsYXJhdGlvbi5sZW5ndGggPT09IDApIHtcblx0XHQvLyBjb25zb2xlLmxvZyhgQWRkaW5nIGltcG9ydCBmb3IgJHtwcm9maWxlSW1wb3J0SWRlbnRpZmllcn0gZnJvbSAke3JlbGF0aXZlUGF0aFRvUHJvZmlsZUltcG9ydH1gKTtcblx0XHRpbXBvcnREZWNsYXJhdGlvbiA9IGouaW1wb3J0RGVjbGFyYXRpb24oXG5cdFx0XHRbai5pbXBvcnREZWZhdWx0U3BlY2lmaWVyKGouaWRlbnRpZmllcihwcm9maWxlSW1wb3J0SWRlbnRpZmllcikpXSxcblx0XHRcdGoubGl0ZXJhbChyZWxhdGl2ZVBhdGhUb1Byb2ZpbGVJbXBvcnQpIC8vIFVzZSBjYWxjdWxhdGVkIHJlbGF0aXZlIHBhdGhcblx0XHQpO1xuXHRcdC8vIEluc2VydCB0aGUgbmV3IGltcG9ydCBkZWNsYXJhdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIGJvZHlcblx0XHRjb25zdCBmaXJzdE5vZGVQYXRoID0gcm9vdC5maW5kKGouUHJvZ3JhbSkuZ2V0KCdib2R5JywgMCk7XG5cdFx0aWYgKGZpcnN0Tm9kZVBhdGgpIHtcblx0XHRcdGZpcnN0Tm9kZVBhdGguaW5zZXJ0QmVmb3JlKGltcG9ydERlY2xhcmF0aW9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRmFsbGJhY2sgaWYgdGhlIGJvZHkgaXMgZW1wdHkgKGUuZy4sIGVtcHR5IGZpbGUpXG5cdFx0XHRyb290LmdldCgpLm5vZGUuYm9keS5wdXNoKGltcG9ydERlY2xhcmF0aW9uKTtcblx0XHR9XG4gXHRcdGlzSW1wb3J0QWRkZWQgPSB0cnVlO1xuIFx0fSBlbHNlIHtcbiBcdFx0Ly8gY29uc29sZS5sb2coYEZvdW5kIGV4aXN0aW5nIGltcG9ydCBmb3IgJHtwcm9maWxlSW1wb3J0SWRlbnRpZmllcn1gKTtcblx0fVxuXG5cdC8vIC0tLSAyLiBGaW5kIGFuZCB0cmFuc2Zvcm0gZHluYW1pYyBpbXBvcnRzLCBhZGRpbmcgdGhlIG1hcmtlciBhcmd1bWVudCAtLS1cbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgcm9vdC5maW5kKGouSW1wb3J0RXhwcmVzc2lvbilcbiAgICAgICAgLmZvckVhY2goaW1wb3J0UGF0aCA9PiB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgRm91bmQgaW1wb3J0OiAke2ooaW1wb3J0UGF0aCkudG9Tb3VyY2UoKX1gKTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIG5vZGUgdG8gcmVwbGFjZSAodGhlIGltcG9ydCBvciB0aGUgYXdhaXQgZXhwcmVzc2lvbiBjb250YWluaW5nIGl0KVxuICAgICAgICAgICAgbGV0IG5vZGVUb1JlcGxhY2UgPSBpbXBvcnRQYXRoO1xuICAgICAgICAgICAgaWYgKGltcG9ydFBhdGgucGFyZW50UGF0aC5ub2RlLnR5cGUgPT09ICdBd2FpdEV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvUmVwbGFjZSA9IGltcG9ydFBhdGgucGFyZW50UGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFscmVhZHkgd3JhcHBlZCBpbXBvcnQgKGJhc2ljIGNoZWNrKVxuICAgICAgICAgICAgaWYgKG5vZGVUb1JlcGxhY2UucGFyZW50UGF0aD8udmFsdWU/LmNhbGxlZT8ubmFtZSA9PT0gcHJvZmlsZUltcG9ydElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnICAgICBTa2lwcGluZyBhbHJlYWR5IHdyYXBwZWQgaW1wb3J0LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc291cmNlIGlzIGEgTGl0ZXJhbCAoZHluYW1pYyBpbXBvcnRzIHJlcXVpcmUgc3RyaW5nIGxpdGVyYWxzKVxuICAgICAgICAgICAgaWYgKGltcG9ydFBhdGgudmFsdWUuc291cmNlICYmIGltcG9ydFBhdGgudmFsdWUuc291cmNlLnR5cGUgPT09ICdMaXRlcmFsJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVBhdGhBcmcgPSBpbXBvcnRQYXRoLnZhbHVlLnNvdXJjZTtcblxuXHRcdFx0XHQvLyBDcmVhdGUgJ2ltcG9ydC5tZXRhLnVybCdcbiAgICAgICAgICAgICAgICBjb25zdCBpbXBvcnRNZXRhVXJsID0gai5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgICAgICBqLm1ldGFQcm9wZXJ0eShqLmlkZW50aWZpZXIoJ2ltcG9ydCcpLCBqLmlkZW50aWZpZXIoJ21ldGEnKSksXG4gICAgICAgICAgICAgICAgICAgIGouaWRlbnRpZmllcigndXJsJylcbiAgICAgICAgICAgICAgICApO1xuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgbWFya2VyIGFyZ3VtZW50XG5cdFx0XHRcdGNvbnN0IG1hcmtlckFyZyA9IGoubGl0ZXJhbChtYXJrZXJTdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHByb2ZpbGVJbXBvcnQobW9kdWxlUGF0aCwgaW1wb3J0Lm1ldGEudXJsLCBudWxsLCBtYXJrZXIpXG5cdFx0XHRcdC8vIFBhc3NpbmcgbnVsbCBmb3IgdGhlIF9pbXBvcnRlciBhcmd1bWVudCBhcyBpdCdzIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZENhbGwgPSBqLmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgICAgICBqLmlkZW50aWZpZXIocHJvZmlsZUltcG9ydElkZW50aWZpZXIpLFxuICAgICAgICAgICAgICAgICAgICBbbW9kdWxlUGF0aEFyZywgaW1wb3J0TWV0YVVybCwgai5saXRlcmFsKG51bGwpLCBtYXJrZXJBcmddXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFdyYXAgaW4gYXdhaXQgaWYgdGhlIG9yaWdpbmFsIGltcG9ydCB3YXMgYXdhaXRlZFxuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlbWVudE5vZGUgPSAobm9kZVRvUmVwbGFjZSA9PT0gaW1wb3J0UGF0aCkgPyB3cmFwcGVkQ2FsbCA6IGouYXdhaXRFeHByZXNzaW9uKHdyYXBwZWRDYWxsKTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgICAgICBSZXBsYWNpbmcgd2l0aDogJHtqKHJlcGxhY2VtZW50Tm9kZSkudG9Tb3VyY2UoKX1gKTtcblxuICAgICAgICAgICAgICAgIGoobm9kZVRvUmVwbGFjZSkucmVwbGFjZVdpdGgocmVwbGFjZW1lbnROb2RlKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVR5cGUgPSBpbXBvcnRQYXRoLnZhbHVlLnNvdXJjZSA/IGltcG9ydFBhdGgudmFsdWUuc291cmNlLnR5cGUgOiAndW5kZWZpbmVkJztcbiAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAgICAgIFNraXBwaW5nIGR5bmFtaWMgaW1wb3J0OiBTb3VyY2UgaXMgbm90IGEgTGl0ZXJhbCAodHlwZTogJHtzb3VyY2VUeXBlfSkuIFNvdXJjZTogJHtqKGltcG9ydFBhdGgpLnRvU291cmNlKCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cdC8vIC0tLSAzLiBSZXR1cm4gbW9kaWZpZWQgc291cmNlIG9ubHkgaWYgY2hhbmdlcyB3ZXJlIG1hZGUgb3IgaW1wb3J0IGFkZGVkIC0tLVxuXHRyZXR1cm4gKGNoYW5nZWQgfHwgaXNJbXBvcnRBZGRlZCkgPyByb290LnRvU291cmNlKHsgcXVvdGU6ICdzaW5nbGUnIH0pIDogZmlsZUluZm8uc291cmNlOyAvLyBVc2Ugc2luZ2xlIHF1b3RlcyBmb3IgY29uc2lzdGVuY3lcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNO0VBQUVBLE9BQU87RUFBRUMsUUFBUTtFQUFFQztBQUFRLENBQUMsR0FBR0MsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUN0RCxNQUFNO0VBQUVDO0FBQWMsQ0FBQyxHQUFHRCxPQUFPLENBQUMsS0FBSyxDQUFDOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxNQUFNRSxpQkFBaUIsR0FBR0MsU0FBUyxDQUFDLENBQUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFNBQVNDLFdBQVdBLENBQUNDLFFBQVEsRUFBRUMsR0FBRyxFQUFFO0VBQUU7RUFDdEQsTUFBTUMsQ0FBQyxHQUFHRCxHQUFHLENBQUNFLFdBQVc7RUFDekIsTUFBTUMsSUFBSSxHQUFHRixDQUFDLENBQUNGLFFBQVEsQ0FBQ0ssTUFBTSxDQUFDO0VBRS9CLE1BQU1DLHVCQUF1QixHQUFHLGVBQWUsQ0FBQyxDQUFDO0VBQ2pELE1BQU1DLFlBQVksR0FBRyxrQkFBa0IsQ0FBQyxDQUFDOztFQUV6QztFQUNBO0VBQ0csTUFBTUMseUJBQXlCLEdBQUdoQixPQUFPLENBQUNHLGlCQUFpQixFQUFFLHlCQUF5QixDQUFDO0VBQ3ZGO0VBQ0EsTUFBTWMsYUFBYSxHQUFHbkIsT0FBTyxDQUFDVSxRQUFRLENBQUNVLElBQUksQ0FBQztFQUM1QztFQUNBLElBQUlDLDJCQUEyQixHQUFHcEIsUUFBUSxDQUFDa0IsYUFBYSxFQUFFRCx5QkFBeUIsQ0FBQztFQUNwRjtFQUNBLElBQUksQ0FBQ0csMkJBQTJCLENBQUNDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUM3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","map":{"version":3,"names":["dirname","relative","resolve","require","fileURLToPath","__dirname_codemod","__dirname","module","exports","transformer","fileInfo","api","j","jscodeshift","root","source","profileImportIdentifier","markerString","profileImportAbsolutePath","targetFileDir","path","relativePathToProfileImport","startsWith","importDeclaration","find","ImportDeclaration","type","value","existingPath","isImportAdded","length","importDefaultSpecifier","identifier","literal","firstNodePath","Program","get","insertBefore","node","body","push","changed","ImportExpression","forEach","importPath","_nodeToReplace$parent","nodeToReplace","parentPath","callee","name","modulePathArg","importMetaUrl","memberExpression","metaProperty","markerArg","wrappedCall","callExpression","replacementNode","awaitExpression","replaceWith","sourceType","console","warn","toSource","quote"],"sourceRoot":"/Users/luketych/Dev/_util/profiler/viscera/codemods/","sources":["inject-profile-import.js"],"sourcesContent":["const { dirname, relative, resolve } = require('path');\nconst { fileURLToPath } = require('url');\n\n// Get the directory of the current module (the codemod file)\n// CommonJS doesn't have import.meta.url, use __filename instead\n// const __filename = fileURLToPath(import.meta.url);\nconst __dirname_codemod = __dirname; // Node provides __dirname in CJS\n\n/**\n * @param {import('jscodeshift').FileInfo} fileInfo\n * @param {import('jscodeshift').API} api\n */\nmodule.exports = function transformer(fileInfo, api) { // Use module.exports\n\tconst j = api.jscodeshift;\n\tconst root = j(fileInfo.source);\n\n\tconst profileImportIdentifier = 'profileImport'; // Consistent identifier name\n\tconst markerString = '__AUTO_PROFILE__'; // Structural marker\n\n\t// --- Calculate relative path dynamically ---\n\t// Absolute path to profileImport.js source file\n    const profileImportAbsolutePath = resolve(__dirname_codemod, '../src/profileImport.js');\n    // Directory of the target file being transformed\n    const targetFileDir = dirname(fileInfo.path);\n    // Calculate the relative path FROM the target file's directory TO profileImport.js\n    let relativePathToProfileImport = relative(targetFileDir, profileImportAbsolutePath);\n    // Normalize path for import statements (e.g., ensure it starts with ./ or ../)\n    if (!relativePathToProfileImport.startsWith('.')) {\n         relativePathToProfileImport = './' + relativePathToProfileImport;\n    }\n\t// console.log(`Calculated relative path to profileImport: ${relativePathToProfileImport}`);\n\n\t// --- 1. Find or add the profileImport import declaration using calculated path ---\n\tlet importDeclaration = root.find(j.ImportDeclaration, {\n\t\tsource: {\n\t\t\ttype: 'Literal',\n\t\t\t// Check if the existing import source resolves to the same absolute path\n\t\t\tvalue: existingPath => resolve(targetFileDir, existingPath) === profileImportAbsolutePath\n\t\t}\n\t});\n\n\tlet isImportAdded = false;\n\tif (importDeclaration.length === 0) {\n\t\t// console.log(`Adding import for ${profileImportIdentifier} from ${relativePathToProfileImport}`);\n\t\timportDeclaration = j.importDeclaration(\n\t\t\t[j.importDefaultSpecifier(j.identifier(profileImportIdentifier))],\n\t\t\tj.literal(relativePathToProfileImport) // Use calculated relative path\n\t\t);\n\t\t// Insert the new import declaration at the beginning of the file body\n\t\tconst firstNodePath = root.find(j.Program).get('body', 0);\n\t\tif (firstNodePath) {\n\t\t\tfirstNodePath.insertBefore(importDeclaration);\n\t\t} else {\n\t\t\t// Fallback if the body is empty (e.g., empty file)\n\t\t\troot.get().node.body.push(importDeclaration);\n\t\t}\n \t\tisImportAdded = true;\n \t} else {\n \t\t// console.log(`Found existing import for ${profileImportIdentifier}`);\n\t}\n\n\t// --- 2. Find and transform dynamic imports, adding the marker argument ---\n    let changed = false;\n\n    root.find(j.ImportExpression)\n        .forEach(importPath => {\n            // console.log(`Found import: ${j(importPath).toSource()}`);\n\n            // Determine node to replace (the import or the await expression containing it)\n            let nodeToReplace = importPath;\n            if (importPath.parentPath.node.type === 'AwaitExpression') {\n                nodeToReplace = importPath.parentPath;\n            }\n\n            // Check for already wrapped import (basic check)\n            if (nodeToReplace.parentPath?.value?.callee?.name === profileImportIdentifier) {\n                // console.log('     Skipping already wrapped import.');\n                return;\n            }\n\n            // Check if source is a Literal (dynamic imports require string literals)\n            if (importPath.value.source && importPath.value.source.type === 'Literal') {\n                const modulePathArg = importPath.value.source;\n\n\t\t\t\t// Create 'import.meta.url'\n                const importMetaUrl = j.memberExpression(\n                    j.metaProperty(j.identifier('import'), j.identifier('meta')),\n                    j.identifier('url')\n                );\n\n\t\t\t\t// Create the marker argument\n\t\t\t\tconst markerArg = j.literal(markerString);\n\n                // Create profileImport(modulePath, import.meta.url, null, marker)\n\t\t\t\t// Passing null for the _importer argument as it's for testing\n                const wrappedCall = j.callExpression(\n                    j.identifier(profileImportIdentifier),\n                    [modulePathArg, importMetaUrl, j.literal(null), markerArg]\n                );\n\n                // Wrap in await if the original import was awaited\n                let replacementNode = (nodeToReplace === importPath) ? wrappedCall : j.awaitExpression(wrappedCall);\n                // console.log(`     Replacing with: ${j(replacementNode).toSource()}`);\n\n                j(nodeToReplace).replaceWith(replacementNode);\n                changed = true;\n            } else {\n                 const sourceType = importPath.value.source ? importPath.value.source.type : 'undefined';\n                 console.warn(`     Skipping dynamic import: Source is not a Literal (type: ${sourceType}). Source: ${j(importPath).toSource()}`);\n            }\n        });\n\n\t// --- 3. Return modified source only if changes were made or import added ---\n\treturn (changed || isImportAdded) ? root.toSource({ quote: 'single' }) : fileInfo.source; // Use single quotes for consistency\n}\n"],"mappings":"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","ignoreList":[]}},"mtime":1746318437200},"{\"assumptions\":{},\"sourceRoot\":\"/Users/luketych/Dev/_util/profiler/viscera/codemods/\",\"configFile\":false,\"babelrc\":false,\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/Users/luketych/Dev/_util/profiler/viscera\",\"filename\":\"/Users/luketych/Dev/_util/profiler/viscera/codemods/remove-profile-import.js\",\"targets\":{},\"cloneInputAst\":true,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"development\",\"root\":\"/Users/luketych/Dev/_util/profiler/viscera\",\"rootMode\":\"root\",\"plugins\":[{\"key\":\"transform-class-properties\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-nullish-coalescing-operator\",\"visitor\":{\"LogicalExpression\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-optional-chaining\",\"visitor\":{\"_exploded\":true,\"OptionalCallExpression\":{\"enter\":[null]},\"OptionalMemberExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-modules-commonjs\",\"visitor\":{\"Program\":{\"exit\":[null]},\"_exploded\":true,\"CallExpression\":{\"enter\":[null]},\"ImportExpression\":{\"enter\":[null]},\"_verified\":true},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-private-methods\",\"visitor\":{\"ExportDefaultDeclaration\":{\"enter\":[null]},\"_exploded\":true,\"_verified\":true,\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]},{\"key\":\"transform-flow-strip-types\",\"visitor\":{\"Program\":{\"enter\":[null]},\"ImportDeclaration\":{\"enter\":[null,null]},\"ClassPrivateProperty\":{\"enter\":[null]},\"AssignmentPattern\":{\"enter\":[null]},\"TypeCastExpression\":{\"enter\":[null,null]},\"CallExpression\":{\"enter\":[null]},\"JSXOpeningElement\":{\"enter\":[null]},\"OptionalCallExpression\":{\"enter\":[null]},\"NewExpression\":{\"enter\":[null]},\"ImportSpecifier\":{\"enter\":[null]},\"ClassExpression\":{\"enter\":[null]},\"ClassDeclaration\":{\"enter\":[null]},\"FunctionDeclaration\":{\"enter\":[null]},\"FunctionExpression\":{\"enter\":[null]},\"ObjectMethod\":{\"enter\":[null]},\"ArrowFunctionExpression\":{\"enter\":[null]},\"ClassMethod\":{\"enter\":[null]},\"ClassPrivateMethod\":{\"enter\":[null]},\"AnyTypeAnnotation\":{\"enter\":[null]},\"ArrayTypeAnnotation\":{\"enter\":[null]},\"BooleanTypeAnnotation\":{\"enter\":[null]},\"BooleanLiteralTypeAnnotation\":{\"enter\":[null]},\"NullLiteralTypeAnnotation\":{\"enter\":[null]},\"ClassImplements\":{\"enter\":[null]},\"DeclareClass\":{\"enter\":[null]},\"DeclareFunction\":{\"enter\":[null]},\"DeclareInterface\":{\"enter\":[null]},\"DeclareModule\":{\"enter\":[null]},\"DeclareModuleExports\":{\"enter\":[null]},\"DeclareTypeAlias\":{\"enter\":[null]},\"DeclareOpaqueType\":{\"enter\":[null]},\"DeclareVariable\":{\"enter\":[null]},\"DeclareExportDeclaration\":{\"enter\":[null]},\"DeclareExportAllDeclaration\":{\"enter\":[null]},\"DeclaredPredicate\":{\"enter\":[null]},\"ExistsTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeAnnotation\":{\"enter\":[null]},\"FunctionTypeParam\":{\"enter\":[null]},\"GenericTypeAnnotation\":{\"enter\":[null]},\"InferredPredicate\":{\"enter\":[null]},\"InterfaceExtends\":{\"enter\":[null]},\"InterfaceDeclaration\":{\"enter\":[null]},\"InterfaceTypeAnnotation\":{\"enter\":[null]},\"IntersectionTypeAnnotation\":{\"enter\":[null]},\"MixedTypeAnnotation\":{\"enter\":[null]},\"EmptyTypeAnnotation\":{\"enter\":[null]},\"NullableTypeAnnotation\":{\"enter\":[null]},\"NumberLiteralTypeAnnotation\":{\"enter\":[null]},\"NumberTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeAnnotation\":{\"enter\":[null]},\"ObjectTypeInternalSlot\":{\"enter\":[null]},\"ObjectTypeCallProperty\":{\"enter\":[null]},\"ObjectTypeIndexer\":{\"enter\":[null]},\"ObjectTypeProperty\":{\"enter\":[null]},\"ObjectTypeSpreadProperty\":{\"enter\":[null]},\"OpaqueType\":{\"enter\":[null]},\"QualifiedTypeIdentifier\":{\"enter\":[null]},\"StringLiteralTypeAnnotation\":{\"enter\":[null]},\"StringTypeAnnotation\":{\"enter\":[null]},\"SymbolTypeAnnotation\":{\"enter\":[null]},\"ThisTypeAnnotation\":{\"enter\":[null]},\"TupleTypeAnnotation\":{\"enter\":[null]},\"TypeofTypeAnnotation\":{\"enter\":[null]},\"TypeAlias\":{\"enter\":[null]},\"TypeAnnotation\":{\"enter\":[null]},\"TypeParameter\":{\"enter\":[null]},\"TypeParameterDeclaration\":{\"enter\":[null]},\"TypeParameterInstantiation\":{\"enter\":[null]},\"UnionTypeAnnotation\":{\"enter\":[null]},\"Variance\":{\"enter\":[null]},\"VoidTypeAnnotation\":{\"enter\":[null]},\"EnumDeclaration\":{\"enter\":[null]},\"EnumBooleanBody\":{\"enter\":[null]},\"EnumNumberBody\":{\"enter\":[null]},\"EnumStringBody\":{\"enter\":[null]},\"EnumSymbolBody\":{\"enter\":[null]},\"EnumBooleanMember\":{\"enter\":[null]},\"EnumNumberMember\":{\"enter\":[null]},\"EnumStringMember\":{\"enter\":[null]},\"EnumDefaultedMember\":{\"enter\":[null]},\"IndexedAccessType\":{\"enter\":[null]},\"OptionalIndexedAccessType\":{\"enter\":[null]},\"ExportAllDeclaration\":{\"enter\":[null]},\"ExportDefaultDeclaration\":{\"enter\":[null]},\"ExportNamedDeclaration\":{\"enter\":[null]}},\"options\":{},\"externalDependencies\":[]}],\"presets\":[]}:7.27.1:development":{"value":{"code":"\"use strict\";\n\nconst {\n  dirname,\n  relative,\n  resolve\n} = require('path');\n\n/**\n * @param {import('jscodeshift').FileInfo} fileInfo\n * @param {import('jscodeshift').API} api\n */\nmodule.exports = function transformer(fileInfo, api) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n  const profileImportIdentifier = 'profileImport'; // Identifier to look for\n  const markerString = '__AUTO_PROFILE__'; // Marker to verify\n  let changed = false;\n\n  // --- 1. Find and unwrap marked profileImport calls ---\n  root.find(j.CallExpression, {\n    callee: {\n      name: profileImportIdentifier\n    }\n  }).forEach(callPath => {\n    // Check if the 4th argument is the marker string\n    const args = callPath.value.arguments;\n    if (args.length >= 4 && args[3].type === 'Literal' && args[3].value === markerString) {\n      // Found a marked call\n      // console.log(`Found marked profileImport call: ${j(callPath).toSource()}`);\n\n      // The original dynamic import expression is the first argument\n      const originalImportArg = args[0];\n\n      // Determine the node to replace (the call expression or its parent await expression)\n      let nodeToReplace = callPath;\n      let replacementNode = j.importExpression(originalImportArg); // Base: import(originalArg)\n\n      if (callPath.parentPath.node.type === 'AwaitExpression') {\n        // console.log('   Parent is AwaitExpression');\n        nodeToReplace = callPath.parentPath;\n        replacementNode = j.awaitExpression(replacementNode); // Wrap: await import(originalArg)\n      }\n\n      // console.log(`   Replacing with: ${j(replacementNode).toSource()}`);\n      j(nodeToReplace).replaceWith(replacementNode);\n      changed = true;\n    }\n  });\n\n  // --- 2. Remove the profileImport import declaration if it's now unused ---\n  if (changed) {\n    // Find the import declaration again\n    const profileImportAbsolutePath = resolve(__dirname, '../src/profileImport.js');\n    const targetFileDir = dirname(fileInfo.path);\n    root.find(j.ImportDeclaration, {\n      source: {\n        type: 'Literal',\n        value: existingPath => resolve(targetFileDir, existingPath) === profileImportAbsolutePath\n      }\n    }).forEach(importDeclPath => {\n      // Check if the default specifier (profileImport) is actually used anywhere else\n      const specifiers = importDeclPath.value.specifiers;\n      if (specifiers && specifiers.length === 1 && specifiers[0].type === 'ImportDefaultSpecifier') {\n        const importName = specifiers[0].local.name;\n        // Count remaining usages of this specific import name\n        const usages = root.find(j.Identifier, {\n          name: importName\n        })\n        // Exclude the import declaration itself from the usage count\n        .filter(idPath => idPath.parentPath !== importDeclPath && idPath.parentPath.value !== specifiers[0]).length;\n\n        // console.log(`Usages found for ${importName}: ${usages}`);\n        if (usages === 0) {\n          // console.log(`Removing unused import declaration for ${importName}`);\n          j(importDeclPath).remove();\n          // No need to set 'changed = true' again, we only remove if other changes were made\n        }\n      }\n    });\n  }\n\n  // --- 3. Return modified source only if changes were made ---\n  return changed ? root.toSource({\n    quote: 'single'\n  }) : fileInfo.source;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkaXJuYW1lIiwicmVsYXRpdmUiLCJyZXNvbHZlIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0cmFuc2Zvcm1lciIsImZpbGVJbmZvIiwiYXBpIiwiaiIsImpzY29kZXNoaWZ0Iiwicm9vdCIsInNvdXJjZSIsInByb2ZpbGVJbXBvcnRJZGVudGlmaWVyIiwibWFya2VyU3RyaW5nIiwiY2hhbmdlZCIsImZpbmQiLCJDYWxsRXhwcmVzc2lvbiIsImNhbGxlZSIsIm5hbWUiLCJmb3JFYWNoIiwiY2FsbFBhdGgiLCJhcmdzIiwidmFsdWUiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ0eXBlIiwib3JpZ2luYWxJbXBvcnRBcmciLCJub2RlVG9SZXBsYWNlIiwicmVwbGFjZW1lbnROb2RlIiwiaW1wb3J0RXhwcmVzc2lvbiIsInBhcmVudFBhdGgiLCJub2RlIiwiYXdhaXRFeHByZXNzaW9uIiwicmVwbGFjZVdpdGgiLCJwcm9maWxlSW1wb3J0QWJzb2x1dGVQYXRoIiwiX19kaXJuYW1lIiwidGFyZ2V0RmlsZURpciIsInBhdGgiLCJJbXBvcnREZWNsYXJhdGlvbiIsImV4aXN0aW5nUGF0aCIsImltcG9ydERlY2xQYXRoIiwic3BlY2lmaWVycyIsImltcG9ydE5hbWUiLCJsb2NhbCIsInVzYWdlcyIsIklkZW50aWZpZXIiLCJmaWx0ZXIiLCJpZFBhdGgiLCJyZW1vdmUiLCJ0b1NvdXJjZSIsInF1b3RlIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvbHVrZXR5Y2gvRGV2L191dGlsL3Byb2ZpbGVyL3Zpc2NlcmEvY29kZW1vZHMvIiwic291cmNlcyI6WyJyZW1vdmUtcHJvZmlsZS1pbXBvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBkaXJuYW1lLCByZWxhdGl2ZSwgcmVzb2x2ZSB9ID0gcmVxdWlyZSgncGF0aCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdqc2NvZGVzaGlmdCcpLkZpbGVJbmZvfSBmaWxlSW5mb1xuICogQHBhcmFtIHtpbXBvcnQoJ2pzY29kZXNoaWZ0JykuQVBJfSBhcGlcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1lcihmaWxlSW5mbywgYXBpKSB7XG4gICAgY29uc3QgaiA9IGFwaS5qc2NvZGVzaGlmdDtcbiAgICBjb25zdCByb290ID0gaihmaWxlSW5mby5zb3VyY2UpO1xuXG4gICAgY29uc3QgcHJvZmlsZUltcG9ydElkZW50aWZpZXIgPSAncHJvZmlsZUltcG9ydCc7IC8vIElkZW50aWZpZXIgdG8gbG9vayBmb3JcbiAgICBjb25zdCBtYXJrZXJTdHJpbmcgPSAnX19BVVRPX1BST0ZJTEVfXyc7IC8vIE1hcmtlciB0byB2ZXJpZnlcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgLy8gLS0tIDEuIEZpbmQgYW5kIHVud3JhcCBtYXJrZWQgcHJvZmlsZUltcG9ydCBjYWxscyAtLS1cbiAgICByb290LmZpbmQoai5DYWxsRXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgY2FsbGVlOiB7IG5hbWU6IHByb2ZpbGVJbXBvcnRJZGVudGlmaWVyIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmZvckVhY2goY2FsbFBhdGggPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIDR0aCBhcmd1bWVudCBpcyB0aGUgbWFya2VyIHN0cmluZ1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IGNhbGxQYXRoLnZhbHVlLmFyZ3VtZW50cztcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+PSA0ICYmIFxuICAgICAgICAgICAgICAgIGFyZ3NbM10udHlwZSA9PT0gJ0xpdGVyYWwnICYmIFxuICAgICAgICAgICAgICAgIGFyZ3NbM10udmFsdWUgPT09IG1hcmtlclN0cmluZykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgbWFya2VkIGNhbGxcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgRm91bmQgbWFya2VkIHByb2ZpbGVJbXBvcnQgY2FsbDogJHtqKGNhbGxQYXRoKS50b1NvdXJjZSgpfWApO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGR5bmFtaWMgaW1wb3J0IGV4cHJlc3Npb24gaXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJbXBvcnRBcmcgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBub2RlIHRvIHJlcGxhY2UgKHRoZSBjYWxsIGV4cHJlc3Npb24gb3IgaXRzIHBhcmVudCBhd2FpdCBleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgIGxldCBub2RlVG9SZXBsYWNlID0gY2FsbFBhdGg7XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2VtZW50Tm9kZSA9IGouaW1wb3J0RXhwcmVzc2lvbihvcmlnaW5hbEltcG9ydEFyZyk7IC8vIEJhc2U6IGltcG9ydChvcmlnaW5hbEFyZylcblxuICAgICAgICAgICAgICAgIGlmIChjYWxsUGF0aC5wYXJlbnRQYXRoLm5vZGUudHlwZSA9PT0gJ0F3YWl0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyAgIFBhcmVudCBpcyBBd2FpdEV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVRvUmVwbGFjZSA9IGNhbGxQYXRoLnBhcmVudFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50Tm9kZSA9IGouYXdhaXRFeHByZXNzaW9uKHJlcGxhY2VtZW50Tm9kZSk7IC8vIFdyYXA6IGF3YWl0IGltcG9ydChvcmlnaW5hbEFyZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYCAgIFJlcGxhY2luZyB3aXRoOiAke2oocmVwbGFjZW1lbnROb2RlKS50b1NvdXJjZSgpfWApO1xuICAgICAgICAgICAgICAgIGoobm9kZVRvUmVwbGFjZSkucmVwbGFjZVdpdGgocmVwbGFjZW1lbnROb2RlKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAvLyAtLS0gMi4gUmVtb3ZlIHRoZSBwcm9maWxlSW1wb3J0IGltcG9ydCBkZWNsYXJhdGlvbiBpZiBpdCdzIG5vdyB1bnVzZWQgLS0tXG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgLy8gRmluZCB0aGUgaW1wb3J0IGRlY2xhcmF0aW9uIGFnYWluXG4gICAgICAgIGNvbnN0IHByb2ZpbGVJbXBvcnRBYnNvbHV0ZVBhdGggPSByZXNvbHZlKF9fZGlybmFtZSwgJy4uL3NyYy9wcm9maWxlSW1wb3J0LmpzJyk7XG4gICAgICAgIGNvbnN0IHRhcmdldEZpbGVEaXIgPSBkaXJuYW1lKGZpbGVJbmZvLnBhdGgpO1xuICAgICAgICBcbiAgICAgICAgcm9vdC5maW5kKGouSW1wb3J0RGVjbGFyYXRpb24sIHtcbiAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXhpc3RpbmdQYXRoID0+IHJlc29sdmUodGFyZ2V0RmlsZURpciwgZXhpc3RpbmdQYXRoKSA9PT0gcHJvZmlsZUltcG9ydEFic29sdXRlUGF0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9KS5mb3JFYWNoKGltcG9ydERlY2xQYXRoID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBkZWZhdWx0IHNwZWNpZmllciAocHJvZmlsZUltcG9ydCkgaXMgYWN0dWFsbHkgdXNlZCBhbnl3aGVyZSBlbHNlXG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpZXJzID0gaW1wb3J0RGVjbFBhdGgudmFsdWUuc3BlY2lmaWVycztcbiAgICAgICAgICAgIGlmIChzcGVjaWZpZXJzICYmIHNwZWNpZmllcnMubGVuZ3RoID09PSAxICYmIHNwZWNpZmllcnNbMF0udHlwZSA9PT0gJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1wb3J0TmFtZSA9IHNwZWNpZmllcnNbMF0ubG9jYWwubmFtZTtcbiAgICAgICAgICAgICAgICAvLyBDb3VudCByZW1haW5pbmcgdXNhZ2VzIG9mIHRoaXMgc3BlY2lmaWMgaW1wb3J0IG5hbWVcbiAgICAgICAgICAgICAgICBjb25zdCB1c2FnZXMgPSByb290LmZpbmQoai5JZGVudGlmaWVyLCB7IG5hbWU6IGltcG9ydE5hbWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24gaXRzZWxmIGZyb20gdGhlIHVzYWdlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpZFBhdGggPT4gaWRQYXRoLnBhcmVudFBhdGggIT09IGltcG9ydERlY2xQYXRoICYmIGlkUGF0aC5wYXJlbnRQYXRoLnZhbHVlICE9PSBzcGVjaWZpZXJzWzBdKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBVc2FnZXMgZm91bmQgZm9yICR7aW1wb3J0TmFtZX06ICR7dXNhZ2VzfWApO1xuICAgICAgICAgICAgICAgIGlmICh1c2FnZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYFJlbW92aW5nIHVudXNlZCBpbXBvcnQgZGVjbGFyYXRpb24gZm9yICR7aW1wb3J0TmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaihpbXBvcnREZWNsUGF0aCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0ICdjaGFuZ2VkID0gdHJ1ZScgYWdhaW4sIHdlIG9ubHkgcmVtb3ZlIGlmIG90aGVyIGNoYW5nZXMgd2VyZSBtYWRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0gMy4gUmV0dXJuIG1vZGlmaWVkIHNvdXJjZSBvbmx5IGlmIGNoYW5nZXMgd2VyZSBtYWRlIC0tLVxuICAgIHJldHVybiBjaGFuZ2VkID8gcm9vdC50b1NvdXJjZSh7IHF1b3RlOiAnc2luZ2xlJyB9KSA6IGZpbGVJbmZvLnNvdXJjZTtcbn07XG4iXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTTtFQUFFQSxPQUFPO0VBQUVDLFFBQVE7RUFBRUM7QUFBUSxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxNQUFNLENBQUM7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFNBQVNDLFdBQVdBLENBQUNDLFFBQVEsRUFBRUMsR0FBRyxFQUFFO0VBQ2pELE1BQU1DLENBQUMsR0FBR0QsR0FBRyxDQUFDRSxXQUFXO0VBQ3pCLE1BQU1DLElBQUksR0FBR0YsQ0FBQyxDQUFDRixRQUFRLENBQUNLLE1BQU0sQ0FBQztFQUUvQixNQUFNQyx1QkFBdUIsR0FBRyxlQUFlLENBQUMsQ0FBQztFQUNqRCxNQUFNQyxZQUFZLEdBQUcsa0JBQWtCLENBQUMsQ0FBQztFQUN6QyxJQUFJQyxPQUFPLEdBQUcsS0FBSzs7RUFFbkI7RUFDQUosSUFBSSxDQUFDSyxJQUFJLENBQUNQLENBQUMsQ0FBQ1EsY0FBYyxFQUFFO0lBQ3BCQyxNQUFNLEVBQUU7TUFBRUMsSUFBSSxFQUFFTjtJQUF3QjtFQUM1QyxDQUFDLENBQUMsQ0FDRE8sT0FBTyxDQUFDQyxRQUFRLElBQUk7SUFDakI7SUFDQSxNQUFNQyxJQUFJLEdBQUdELFFBQVEsQ0FBQ0UsS0FBSyxDQUFDQyxTQUFTO0lBQ3JDLElBQUlGLElBQUksQ0FBQ0csTUFBTSxJQUFJLENBQUMsSUFDaEJILElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQ0ksSUFBSSxLQUFLLFNBQVMsSUFDMUJKLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsS0FB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","map":{"version":3,"names":["dirname","relative","resolve","require","module","exports","transformer","fileInfo","api","j","jscodeshift","root","source","profileImportIdentifier","markerString","changed","find","CallExpression","callee","name","forEach","callPath","args","value","arguments","length","type","originalImportArg","nodeToReplace","replacementNode","importExpression","parentPath","node","awaitExpression","replaceWith","profileImportAbsolutePath","__dirname","targetFileDir","path","ImportDeclaration","existingPath","importDeclPath","specifiers","importName","local","usages","Identifier","filter","idPath","remove","toSource","quote"],"sourceRoot":"/Users/luketych/Dev/_util/profiler/viscera/codemods/","sources":["remove-profile-import.js"],"sourcesContent":["const { dirname, relative, resolve } = require('path');\n\n/**\n * @param {import('jscodeshift').FileInfo} fileInfo\n * @param {import('jscodeshift').API} api\n */\nmodule.exports = function transformer(fileInfo, api) {\n    const j = api.jscodeshift;\n    const root = j(fileInfo.source);\n\n    const profileImportIdentifier = 'profileImport'; // Identifier to look for\n    const markerString = '__AUTO_PROFILE__'; // Marker to verify\n    let changed = false;\n\n    // --- 1. Find and unwrap marked profileImport calls ---\n    root.find(j.CallExpression, {\n            callee: { name: profileImportIdentifier }\n        })\n        .forEach(callPath => {\n            // Check if the 4th argument is the marker string\n            const args = callPath.value.arguments;\n            if (args.length >= 4 && \n                args[3].type === 'Literal' && \n                args[3].value === markerString) {\n                \n                // Found a marked call\n                // console.log(`Found marked profileImport call: ${j(callPath).toSource()}`);\n\n                // The original dynamic import expression is the first argument\n                const originalImportArg = args[0];\n\n                // Determine the node to replace (the call expression or its parent await expression)\n                let nodeToReplace = callPath;\n                let replacementNode = j.importExpression(originalImportArg); // Base: import(originalArg)\n\n                if (callPath.parentPath.node.type === 'AwaitExpression') {\n                    // console.log('   Parent is AwaitExpression');\n                    nodeToReplace = callPath.parentPath;\n                    replacementNode = j.awaitExpression(replacementNode); // Wrap: await import(originalArg)\n                }\n                \n                // console.log(`   Replacing with: ${j(replacementNode).toSource()}`);\n                j(nodeToReplace).replaceWith(replacementNode);\n                changed = true;\n            }\n        });\n\n    // --- 2. Remove the profileImport import declaration if it's now unused ---\n    if (changed) {\n        // Find the import declaration again\n        const profileImportAbsolutePath = resolve(__dirname, '../src/profileImport.js');\n        const targetFileDir = dirname(fileInfo.path);\n        \n        root.find(j.ImportDeclaration, {\n            source: {\n                type: 'Literal',\n                value: existingPath => resolve(targetFileDir, existingPath) === profileImportAbsolutePath\n            }\n        }).forEach(importDeclPath => {\n            // Check if the default specifier (profileImport) is actually used anywhere else\n            const specifiers = importDeclPath.value.specifiers;\n            if (specifiers && specifiers.length === 1 && specifiers[0].type === 'ImportDefaultSpecifier') {\n                const importName = specifiers[0].local.name;\n                // Count remaining usages of this specific import name\n                const usages = root.find(j.Identifier, { name: importName })\n                                  // Exclude the import declaration itself from the usage count\n                                  .filter(idPath => idPath.parentPath !== importDeclPath && idPath.parentPath.value !== specifiers[0]) \n                                  .length;\n                \n                // console.log(`Usages found for ${importName}: ${usages}`);\n                if (usages === 0) {\n                    // console.log(`Removing unused import declaration for ${importName}`);\n                    j(importDeclPath).remove();\n                    // No need to set 'changed = true' again, we only remove if other changes were made\n                }\n            }\n        });\n    }\n\n    // --- 3. Return modified source only if changes were made ---\n    return changed ? root.toSource({ quote: 'single' }) : fileInfo.source;\n};\n"],"mappings":"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","ignoreList":[]}},"mtime":1746319099212}}